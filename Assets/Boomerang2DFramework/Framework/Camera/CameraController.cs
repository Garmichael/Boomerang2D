using System;
using System.Collections.Generic;
using Boomerang2DFramework.Framework.Actors;
using Boomerang2DFramework.Framework.MapGeneration;
using Boomerang2DFramework.Framework.StateManagement;
using Boomerang2DFramework.Framework.Utilities;
using UnityEngine;

namespace Boomerang2DFramework.Framework.Camera {
	/// <summary>
	/// MonoBehavior that controls the Camera's behavior. 
	/// </summary>
	/// <remarks>
	/// The CameraController doesn't render a camera directly to the viewport. Instead, it manages a collection
	/// of RenderTextures generated by LayerCameraControllers, and renders each of those RenderTextures to the
	/// GUI Layer on each frame. 
	/// </remarks>
	public class CameraController : MonoBehaviour {
		public Actor Target;
		public MapViewBehavior CurrentView;
		public Vector3 RealPosition;
		public Vector3 DestinationPosition;
		public float HorizontalLerpSpeed;
		public float VerticalLerpSpeed;
		public float OrthographicSize;
		public float Aspect;

		public StateMachine StateMachine;

		private readonly Dictionary<string, MapCameraLayer> _mapCameraLayers = new();
		private readonly Dictionary<string, LayerCameraController> _uiCameraLayers = new();

		private struct MapCameraLayer {
			public MapLayerBehavior MapLayerBehavior;
			public LayerCameraController LayerCameraController;
		}

		private Vector3 _velocity = Vector3.zero;

		private void Start() {
			StateMachine = new StateMachine();
			OrthographicSize = GameProperties.DefaultCameraSize;
			Aspect = GameProperties.AspectRatio;
		}

		private void LateUpdate() {
			if (Target == null) {
				return;
			}

			StateMachine.ProcessSetUpFrameState();
			StateMachine.UpdateState();
			StateMachine.ProcessState();

			LerpToDestinationPosition();
			UpdateMapLayerCameras();

			StateMachine.ProcessPostFrameState();
		}

		private void LerpToDestinationPosition() {
			RealPosition = new Vector3(
				Vector3.SmoothDamp(
					RealPosition,
					DestinationPosition,
					ref _velocity,
					HorizontalLerpSpeed * GameProperties.PixelSize
				).x,
				Vector3.SmoothDamp(
					RealPosition,
					DestinationPosition,
					ref _velocity,
					VerticalLerpSpeed * GameProperties.PixelSize
				).y,
				RealPosition.z
			);

			transform.localPosition = BoomerangUtils.RoundToPixelPerfection(RealPosition);
		}

		private void UpdateMapLayerCameras() {
			foreach (KeyValuePair<string, MapCameraLayer> mapCameraLayer in _mapCameraLayers) {
				mapCameraLayer.Value.MapLayerBehavior.UpdateLayerCameraPosition();
			}
		}

		public void SetCurrentView(MapViewBehavior newView) {
			if (CurrentView == newView) {
				return;
			}

			if (CurrentView) {
				CurrentView.DefaultCameraState.OnExitState();
			}

			CurrentView = newView;
			newView.DefaultCameraState.OnEnterState();
			StateMachine.SetNextState(newView.DefaultCameraState);
		}


		public void AddMapLayerRender(string mapName, MapLayerBehavior mapLayerBehavior, LayerCameraController layerCameraController) {
			_mapCameraLayers.Add(mapName, new MapCameraLayer {
				MapLayerBehavior = mapLayerBehavior,
				LayerCameraController = layerCameraController
			});
		}

		public void AddUiLayerRender(string hudObjectName, LayerCameraController layerCameraController) {
			_uiCameraLayers.Add(hudObjectName, layerCameraController);
		}

		public void ClearAllMapLayers() {
			_mapCameraLayers.Clear();
		}

		public void ClearUiLayer(string hudObjectName) {
			_uiCameraLayers.Remove(hudObjectName);
		}

		/// <summary>
		/// Renders all the LayerCamera RenderTextures to the screen
		/// </summary>
		private void OnGUI() {
			GL.Clear(false, true, Color.clear);

			GUI.BeginGroup(new Rect(0, 0, Screen.width, Screen.height));
			foreach (KeyValuePair<string, MapCameraLayer> mapCameraLayer in _mapCameraLayers) {
				RenderLayer(mapCameraLayer.Value.LayerCameraController.RenderTexture, mapCameraLayer.Value.LayerCameraController.Material);
			}

			foreach (KeyValuePair<string, LayerCameraController> uiCameraLayer in _uiCameraLayers) {
				RenderLayer(uiCameraLayer.Value.RenderTexture, uiCameraLayer.Value.Material);
			}

			GUI.EndGroup();
		}

		private void RenderLayer(RenderTexture renderTexture, Material material) {
			Rect screenRenderRect = GetRenderRect();
			Graphics.DrawTexture(screenRenderRect, renderTexture, material);
		}

		private Rect GetRenderRect() {
			Rect screenRenderRect = new Rect();
			float scaleX = Screen.width / (float) GameProperties.RenderDimensionsWidth;
			float scaleY = Screen.height / (float) GameProperties.RenderDimensionsHeight;

#pragma warning disable 0162
			switch (GameProperties.RenderDisplayMode) {
				case RenderDisplayMode.PixelPerfect:
					float maxScale = scaleX < scaleY
						? scaleX
						: scaleY;

					maxScale = Mathf.FloorToInt(maxScale);
					maxScale = BoomerangUtils.MinValue(maxScale, 1);
					screenRenderRect.width = GameProperties.RenderDimensionsWidth * maxScale;
					screenRenderRect.height = GameProperties.RenderDimensionsHeight * maxScale;
					break;
				case RenderDisplayMode.Stretch:
					screenRenderRect.width = Screen.width;
					screenRenderRect.height = Screen.height;
					break;
				case RenderDisplayMode.Fit:
					screenRenderRect.width = scaleX > scaleY
						? Screen.height * GameProperties.AspectRatio
						: Screen.width;

					screenRenderRect.height = scaleX > scaleY
						? Screen.height
						: Screen.width / GameProperties.AspectRatio;
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}
#pragma warning restore 0162

			if (screenRenderRect.width < Screen.width) {
				screenRenderRect.x = (Screen.width - screenRenderRect.width) / 2;
			}

			if (screenRenderRect.height < Screen.height) {
				screenRenderRect.y = (Screen.height - screenRenderRect.height) / 2;
			}

			return screenRenderRect;
		}
	}
}